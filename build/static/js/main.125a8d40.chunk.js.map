{"version":3,"sources":["components/UserList.js","newestAttempt.js","serviceWorker.js","index.js"],"names":["UserList","props","users","handleUserClick","listElements","map","user","key","onClick","style","cursor","listStyleType","peerConnection","myStream","localVideo","remoteVideo","targetUser","dataChannel","myLocation","socket","openSocket","window","location","origin","replace","streamSenders","pcConfig","constraints","video","audio","allowRenegotionationOutsideVar","connectedToUser","App","useState","myID","setMyID","setUsers","remoteLocation","setRemoteLocation","showTextInput","setShowTextInput","screenShareBtnText","setScreenShareBtnText","allowRenegotionation","setAllowRenegotiation","setReadyToInitialize","useEffect","fetch","then","res","json","data","console","log","state","country_name","on","iceServers","filter","userID","a","offersID","JSON","stringify","offer","navigator","mediaDevices","getUserMedia","setStream","RTCPeerConnection","getTracks","forEach","track","sender","addTrack","push","ondatachannel","receiveDataChannel","setRemoteDescription","ontrack","receivedStream","onicecandidate","sendIceCandidate","onnegotiationneeded","handleNegotiation","generateAnswer","document","getElementById","value","answer","setTimeout","candidate","addIceCandidate","RTCIceCandidate","generateOffer","socketRoute","renegotiation","createOffer","setLocalDescription","emit","createAnswer","e","alert","target","innerText","createDataChannel","ordered","maxPacketLifeTime","onopen","onmessage","dataChannelMessage","sendTextMessage","textarea","messagesContainer","textContent","scrollTop","scrollHeight","send","width","muted","srcObject","error","src","URL","createObjectURL","event","streams","channel","handleScreenShare","getDisplayMedia","tempMyStream","kind","stop","removeTrack","className","length","getStats","stats","obj","type","selected","candidateType","ipAddress","get","id","autoPlay","height","fontSize","onKeyUp","maxHeight","overflowY","Boolean","hostname","match","ReactDOM","render","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.125a8d40.chunk.js","sourcesContent":["import React from 'react'\n\nexport default function UserList(props) {\n    const {users, handleUserClick} = props\n\n    const listElements = users.map((user) => {\n        return <li key={user} onClick={handleUserClick} style={{cursor: \"pointer\"}}>{user}</li>\n    })\n\n    return (\n        <div>\n            <ul style={{listStyleType: \"none\"}}>\n                {listElements}\n            </ul>\n        </div>\n    )\n}\n","import React, { useEffect, useState, Fragment } from 'react';\nimport './App.css';\nimport openSocket from 'socket.io-client';\nimport UserList from './components/UserList'\n// const port = process.env.PORT || 8000;\n\n// console.log(`ws://${window.location.hostname}:${port}`)\nvar socket = openSocket(window.location.origin.replace(/^http/, 'ws'));\nvar peerConnection\nvar myStream\nvar streamSenders = []\nvar localVideo\nvar remoteVideo\nvar pcConfig = {\n    'iceServers': []\n  };\nvar constraints = { video: true, audio: true };\nvar targetUser\nvar dataChannel\nvar myLocation\nvar allowRenegotionationOutsideVar = false\nvar connectedToUser = false\n\nfunction App() {\n    const [myID, setMyID] = useState(null)\n    const [users, setUsers] = useState([])\n    const [remoteLocation, setRemoteLocation] = useState(null)\n    const [showTextInput, setShowTextInput] = useState(false)\n    const [screenShareBtnText, setScreenShareBtnText] = useState(\"Start ScreenShare\")\n    var [allowRenegotionation, setAllowRenegotiation] = useState(false)\n    const [streamInitialized, setStreamInitialized] = useState(false)\n    const [readyToInitialize, setReadyToInitialize] = useState(false)\n\n\n    useEffect(() => {\n\n        fetch(\"https://geolocation-db.com/json/\")\n        .then(res => res.json())\n        .then(data => {\n            console.log(data)\n            const location = data.state ? `${data.state}, ${data.country_name}` : `${data.country_name}`\n            myLocation = location})\n\n        socket.on('get_id', data => {\n            console.log(\"Connected to websocket\")\n            if (data.iceServers[0]) {\n                pcConfig['iceServers'] = data.iceServers\n            }\n            setMyID(data.myID)\n            setUsers(data.users)\n            console.log(\"pcConfig\", pcConfig)\n        })\n\n    }, [])\n\n    useEffect(() => {\n        if (myID) {\n            socket.on('new_person', data => {\n                setUsers(data.filter((userID => {\n                    return userID !== myID\n                })))\n            })\n\n            socket.on('remove_user', (data) => {\n                setUsers(data.filter((userID => {\n                    return userID !== myID\n                })))\n            })\n\n            socket.on('incoming_offer', async(data) => {\n                console.log(`Incoming offer from ${data.offersID}: ${JSON.stringify(data.offer)}`)\n                targetUser = data.offersID\n                setRemoteLocation(data.location)\n\n                myStream = await navigator.mediaDevices.getUserMedia(constraints);\n                setStream()\n                peerConnection = new RTCPeerConnection(pcConfig)\n                myStream.getTracks().forEach((track) => {\n                    let sender = peerConnection.addTrack(track, myStream)\n                    streamSenders.push(sender)\n                })\n                peerConnection.ondatachannel = receiveDataChannel\n                // dataChannel = peerConnection.createDataChannel('text', {\n                //     ordered: true, // guarantees order\n                //     maxPacketLifeTime: 3000\n                //   })\n                // dataChannel.onopen = () => {console.log(\"DataChannel Open\")}\n                // dataChannel.onmessage = dataChannelMessage\n                peerConnection.setRemoteDescription(data.offer)\n                peerConnection.ontrack = receivedStream\n                peerConnection.onicecandidate = sendIceCandidate\n                peerConnection.onnegotiationneeded = handleNegotiation\n                generateAnswer(false)\n\n                document.getElementById('otherID').value = JSON.stringify(data.offer)\n                // setStreamInitialized(true)\n            })\n\n            socket.on('incoming_answer', function (data) {\n                connectedToUser = true\n                setRemoteLocation(data.location)\n                console.log(`Incoming answer: ${JSON.stringify(data.answer)}`)\n                peerConnection.setRemoteDescription(data.answer)\n                document.getElementById('otherID').value = JSON.stringify(data.answer)\n                console.log(peerConnection)\n                setShowTextInput(true)\n                setTimeout(() => {\n                    setAllowRenegotiation(true)\n                }, 3000)\n                // setStreamInitialized(true)\n            })\n\n            socket.on(\"incoming_candidate\", function (candidate){\n                console.log(\"candidate\", candidate)\n                if (peerConnection) {\n                    peerConnection.addIceCandidate(new RTCIceCandidate(candidate))\n                }\n            })\n\n            socket.on(\"incoming_renegotiation_offer\", function(data){\n                console.log(data)\n                console.log(peerConnection)\n                peerConnection.setRemoteDescription(data.offer)\n                generateAnswer(true, data)\n                document.getElementById('otherID').value = JSON.stringify(data.offer)\n            })\n\n            socket.on(\"incoming_renegotiation_answer\", function(data){\n                console.log(data)\n                peerConnection.setRemoteDescription(data.answer)\n                document.getElementById('otherID').value = JSON.stringify(data.answer)\n            })\n        }\n    }, [myID])\n\n    useEffect(() => {\n        if (allowRenegotionation) {\n            allowRenegotionationOutsideVar = true\n        }\n    }, [allowRenegotionation])\n\n    const generateOffer = (renegotiation = false, data = false) => {\n        let socketRoute\n        if (renegotiation && allowRenegotionationOutsideVar) {\n            socketRoute = 'renegotiation_offer_to_user'\n        } else if (!renegotiation) {\n            socketRoute = 'offer_to_user'\n        }\n\n        console.log(\"genOffer\", renegotiation, allowRenegotionationOutsideVar, socketRoute)\n\n        if (socketRoute) {\n            peerConnection.createOffer().then((offer) => {\n                peerConnection.setLocalDescription(offer)\n                socket.emit(socketRoute, {\n                    targetUser: targetUser,\n                    myID: myID,\n                    offer: offer,\n                    location: myLocation\n                })\n                document.getElementById('yourID').value = JSON.stringify(offer)\n            })\n        }\n    }\n\n    const generateAnswer = (renegotiation = false, data = false) => {\n        let socketRoute\n        if (renegotiation && allowRenegotionationOutsideVar) {\n            socketRoute = 'renegotiation_answer_to_user'\n        } else if (!renegotiation) {\n            socketRoute = 'answer_to_user'\n        }\n\n        console.log(\"genAnswer\", renegotiation, allowRenegotionationOutsideVar, socketRoute)\n\n        if (socketRoute) {\n            peerConnection.createAnswer().then((answer) => {\n                peerConnection.setLocalDescription(answer)\n                socket.emit(socketRoute, {\n                    targetUser: targetUser,\n                    answer: answer,\n                    location: myLocation\n                })\n                document.getElementById('yourID').value = JSON.stringify(answer)\n            })\n            setTimeout(() => {\n                setAllowRenegotiation(true)\n            }, 3000)\n        }\n    } \n\n    const handleUserClick = async(e) => {\n        \n        if (connectedToUser) {alert(\"Already connecting/connected to user\"); return;}\n        \n        connectedToUser = true\n\n        targetUser = e.target.innerText\n\n        myStream = await navigator.mediaDevices.getUserMedia(constraints);\n        setStream()\n        peerConnection = new RTCPeerConnection(pcConfig)\n        myStream.getTracks().forEach((track) => {\n            let sender = peerConnection.addTrack(track, myStream)\n            streamSenders.push(sender)\n        })\n        dataChannel = peerConnection.createDataChannel('text', {\n            ordered: true, // guarantees order\n            maxPacketLifeTime: 3000\n          })\n        dataChannel.onopen = () => {console.log(\"DataChannel Open\")}\n        dataChannel.onmessage = dataChannelMessage\n        peerConnection.ontrack = receivedStream\n        peerConnection.onicecandidate = sendIceCandidate\n        peerConnection.onnegotiationneeded = handleNegotiation\n\n        generateOffer()\n\n    }\n\n    const hasUserMedia = () => { \n        //check if the browser supports the WebRTC \n        return !!(navigator.getUserMedia || navigator.webkitGetUserMedia || \n           navigator.mozGetUserMedia); \n      } \n\n    const sendTextMessage = () => {\n        const textarea = document.getElementById('yourMessage')\n        let messagesContainer = document.getElementById('messages')\n\n        messagesContainer.textContent = messagesContainer.textContent + \"Me: \" + textarea.value + \"\\n\" + \"------\\n\"\n        messagesContainer.scrollTop = messagesContainer.scrollHeight;\n        dataChannel.send(textarea.value)\n        textarea.value = \"\"\n    }\n\n    const handleTextAreaEnter = (event) => {\n        if (event.key === \"Enter\") {\n            const textarea = document.getElementById('yourMessage')\n            textarea.value = textarea.value\n            sendTextMessage()\n        }\n    }\n    \n    const setStream = () => {\n        localVideo = document.getElementById('myVideo'); \n        localVideo.width = 500\n        localVideo.muted = true\n        try {\n            localVideo.srcObject = myStream;\n        } catch (error) {\n            localVideo.src = window.URL.createObjectURL(myStream);\n        }\n\n        setReadyToInitialize(true)\n    }\n\n    const receivedStream = (event) => {\n        remoteVideo = document.getElementById('theirVideo')\n        remoteVideo.width = 500\n\n        console.log(event)\n        try {\n            remoteVideo.srcObject = event.streams[0];\n        } catch (error) {\n            remoteVideo.src = window.URL.createObjectURL(event.streams[0]);\n        }\n        \n        console.log(localVideo.srcObject)\n        console.log(remoteVideo.srcObject)\n    }\n\n    const sendIceCandidate = (event) => {\n        if (event.candidate) {\n            socket.emit('candidate', {candidate: event.candidate, targetUser: targetUser})\n        }\n    }\n\n    const dataChannelMessage = (event) => {\n        let messagesContainer = document.getElementById('messages')\n        messagesContainer.textContent = messagesContainer.textContent + event.data + \"\\n\" + \"------\\n\"\n        messagesContainer.scrollTop = messagesContainer.scrollHeight;\n    }\n\n    const receiveDataChannel = (event) => {\n        dataChannel = event.channel\n        dataChannel.onopen = () => {console.log(\"DataChannel Open\")}\n        dataChannel.onmessage = dataChannelMessage\n        setShowTextInput(true)\n    }\n\n    // const handleTrack = (event) => {\n    //     remoteVideo = document.getElementById('theirVideo')\n    //     remoteVideo.width = 500\n    //     console.log(event)\n    //     if (event.streams && event.streams[0]) {\n    //         remoteVideo.srcObject = event.streams[0];\n    //     } else {\n    //         let inboundStream = new MediaStream(event.track[0]);\n    //         remoteVideo.srcObject = inboundStream;\n    //     }\n    // }\n\n    const handleNegotiation = async (event) => {\n        console.log(\"here\", event)\n        generateOffer(true, event)\n    }\n\n    const handleScreenShare = async () => {\n        \n        if (screenShareBtnText === \"Start ScreenShare\") {\n            let tempMyStream = await navigator.mediaDevices.getDisplayMedia()\n            myStream.getTracks().forEach((track) => {\n                if (track.kind !== \"audio\") {\n                    track.stop()\n                } else {\n                    tempMyStream.addTrack(track)\n                    track.stop()\n                }\n            })\n            myStream = tempMyStream\n            console.log(myStream.getTracks())\n            setScreenShareBtnText(\"Start Video\")\n        } else {\n            let tempMyStream = await navigator.mediaDevices.getUserMedia(constraints);\n            myStream.getTracks().forEach((track) => {\n                track.stop()\n            })\n            myStream = tempMyStream\n            setScreenShareBtnText(\"Start ScreenShare\")\n        }\n        console.log(myStream.getTracks())\n        console.log(peerConnection)\n\n        localVideo = document.getElementById('myVideo'); \n        localVideo.width = 500\n        localVideo.muted = true\n        try {\n            localVideo.srcObject = myStream;\n        } catch (error) {\n            localVideo.src = window.URL.createObjectURL(myStream);\n        }\n    \n\n        streamSenders.forEach((sender) => {\n            peerConnection.removeTrack(sender)\n        })\n\n        streamSenders = []\n\n        myStream.getTracks().forEach((track) => {\n           let sender = peerConnection.addTrack(track, myStream)\n           streamSenders.push(sender)\n        })\n\n        console.log(peerConnection)\n\n    }\n\n    const handleGetStats = () => {\n        peerConnection.getStats(null)\n        .then(stats => stats.forEach(obj => {\n            if(obj.type === \"candidate-pair\" && obj.selected) {\n                console.log(obj);\n                if (obj.candidateType == \"relayed\") {\n                    console.log(\"Uses TURN server: \" + obj.ipAddress);\n                  } else {\n                    console.log(\"Does not use TURN (uses \" + obj.candidateType + \").\");\n                  }\n                \n                  if (obj[\"localCandidateId\"]){\n                    console.log(\"localCandidateId Get\", stats.get(obj[\"localCandidateId\"]))\n                }\n                if (obj[\"remoteCandidateId\"]){\n                    console.log(\"remoteCandidateId Get\", stats.get(obj[\"remoteCandidateId\"]));\n                }\n            }\n        })\n      )\n        peerConnection.getStats(null)\n            .then(stats => stats.forEach(obj => {\n                if(obj.type === \"candidate-pair\"){\n                    console.log(obj)\n                }\n            })\n        )\n\n        console.log(peerConnection)\n    }\n\n    return (\n        <div className=\"App\">\n\n            {users.length > 0 ? <UserList users={users} handleUserClick={handleUserClick}></UserList> : null}\n\n            {allowRenegotionation ? <button onClick={handleScreenShare}>{screenShareBtnText}</button> : <button>Welcome!</button>}<br/>\n            <button onClick={handleGetStats}>Get Stats</button><br/>\n            \n            {remoteLocation && targetUser ? \n            <Fragment>\n                <strong id=\"remote-user\">Connected to: {targetUser}</strong><br/>\n                <strong id=\"remote-location\">Location: {remoteLocation}</strong><br/>\n            </Fragment> : null\n            }\n    \n            <video id=\"myVideo\" autoPlay></video>\n            <spacer type=\"block\"> </spacer>\n            <video id=\"theirVideo\" autoPlay></video>\n            <br></br>\n            <br></br>\n            { showTextInput ? \n            <Fragment>\n            <label>Enter message</label><br />\n            <input id=\"yourMessage\" type=\"text\" style={{width: 190, height: 25, fontSize: 16}} onKeyUp={handleTextAreaEnter}></input>\n            <button id=\"send\" onClick={sendTextMessage}>Send</button>\n            <pre id=\"messages\" style={{maxHeight: 150, overflowY: \"scroll\"}}></pre> <br />\n            </Fragment>\n            : null\n            }\n            \n            <label>Your ID:</label><br />\n            <textarea id=\"yourID\"></textarea><br />\n            <label>Other ID:</label><br />\n            <textarea id=\"otherID\"></textarea><br />\n\n        </div>\n    );\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n// import App from './App';\nimport App from './newestAttempt'\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}